主要是借鉴 nestjs 模块化的概念，来组织 react 的整体结构，将依赖拆分到 core 以及 common 基础包，来实现 react 代码的模块化开发

## 背景

前端项目的迭代逐步往复杂化以及多样化来发展，一个前端组十几二十个项目都很常见，后续维护起来全是灾难，代码的组织架构都在不断的迭代

此外即使内部开发了组件库来做代码共享，很多时候也是单纯的 UI 组件，无法包含请求以及复杂的业务逻辑， 而纯 UI 组件对于组内而言相对价值没有那么大，很多时候需要的是一整套的业务逻辑的自由组合

因此很多人都在推行微前端，配合后端微服务，将专门的功能提取到专门的前端页面，这样前端只需要组合服务模块即可，可以说是简单直接

但是微前端实际上就是将项目小型化，十几个项目都维护不过来，现在拆成微前端只会更多，维护起来难度更大，当然也可以使用比如说 monorepo 去减少维护成本

微前端最大的优势在于可以将不同框架的项目无缝衔接在一起，但是大部分的前端组都统一了语言和技术栈，框架选型以及组件库的挑选基本上都是确定的，这个时候使用微前端，感觉只会增加使用成本

本项目更倾向于将底层的差异全都抹平，然后提供一套模块化的接口设计，只要适配这套接口即可实现跨项目的组合，实现一套 react 技术栈下的跨项目业务共享方案

## 设计

很多人推崇微前端主要是认为巨石应用的开发跟维护都是灾难，但是个人认为，开发-构建-测试-部署这几个阶段应该区分开来，不能因为测试困难就要凭空增加开发的成本，而是应该将环节解锁，尽可能的提升每个环节的效率，这样才能成本最小化

从开发的角度来说，拿到需求然后针对性的开发测试，最后部署到成品库，这个就是最小路径，但是问题在于，前端从来都不是一个可以自由分割的部分，不可避免的依赖众多组件库，国际化跟状态管理无法脱离项目存在，webpack 这类还能用构建流程去处理，但是业务依赖则很难处理

因此我们首要解决的就是，如何将一个前端组件完整的隔离开来，同时又能方便的在测试环境与生产环境一致性复现，nestjs 的模块就十分适合这种情况，只依赖 core 包，同时能够随意迁移到任何项目

然后就是需要将模块组合的逻辑抽象成通用接口，这样就能实现模块自由组合，国际化和状态管理等核心逻辑存放在 core 包即可

但是一个问题在于，当项目庞大到了几是上百个模块的时候，可能会比较难维护，因此需要将模块一级级的分开，这样最外层项目只依赖一级模块，然后一级模块再依赖二级模块，层级上会比较清晰，唯一的难点就在于框架的开发需要支持模块的横向以及纵向拓展

这对构建也提出了比较高的要求，需要建立一个统一的构建平台，通过一定的条件自动触发构建，这样成本就完全能够接受

虽然能够解决开发的问题，但还是不可避免的会有部署的问题，业务模块如果包含了接口请求，那就不是静态模块了，需要做成动态模块，每次更新都会触发整个项目的更新，风险可能会有点大，但是这个从理论上来说，就是流程的问题了，只要保证开发的纯粹以及隔离，那么风险也是可控的

## 方向

到底是走 class 这种比较成熟的方案，还是走类似 react 的函数式这也是个问题，前者有大量可以借鉴的部分，后者则需要参考同类实现然后出一套类似的

不过话说回来，前者有 angular 这种比较完善的，重新做一套的意义也不大，还不如直接基于函数式的重新整一套，最起码契合 react 一点，也能有一点新意

两种都尝试一下，然后看看开发时哪种更友好吧

## 结构

- core: 核心逻辑，主要包含基础依赖，模块抽象以及组合逻辑等
- common：公共包，包括工具类以及请求类等
- plugins：插件包，一个完整的插件应该包含 核心的 middleware 和 模块的 hooks
- cli：脚手架，用于快速的开发和测试

## 模块

### core

core 是核心部分，最开始将很多东西都打包进去了，但是仔细思考下，可以讲很多东西都剔除掉

首先的职责就是定义好 module 的边界以及 interface，包括模块的相互组合以及依赖问题，其次就是将模块的依赖抽离出来然后集成到一起，由于目前需要打包，因此暂时不考虑运行时动态加载模块，统一在构建的时候去处理以来等问题

可以抽象下，core 实现一种插件加载机制，把 API 提供出来，这样就能实现随意拓展的功能

参考 nestjs, 可以添加 middleware 的抽象层，这样就能将国际化单独做个库，并让自定义的逻辑由用户提供

以国际化为例，它应该是个单独的包，同时有主函数以及子函数部分，主函数主要用来定义核心的逻辑组合与生成，子函数则用于各个模块直接调用，每个模块的路由文件都借助 provider 直接挂载到模块上，然后 core 在处理每个模块的时候，利用中间件机制暴露给主函数去处理，同时生成外层的 provider，这样就能比较完美的将这部分解耦了

有几点要注意：

1. 通过 provider 挂载的文件要怎么去识别处理，如果只是单纯的挂到 module 对象上，很容易就出现 key 冲突，这样就会造成 core 处理的 BUG，但是又不能直接用 symbol,因为子模块安装的国际化包跟项目安装的很可能不是同一个，那就会导致生成的 symbol 不一样，可能还是需要唯一 KEY 去确认

2. 主函数处理的时候，模块的不同遍历顺序是否会对最终结果造成影响，从理论上来说是使用递归遍历，但是一旦遇到循环依赖就可能会导致故障，其次这种遍历也可能影响内部

3. 前端基本上是要注册一些信息到外部的 provider 的，如果让外部直接注册组件，那么就可能导致组件的层级非常乱，大量的外部数据直接汇聚到顶层，可能会造成心智负担

目前这三点都可以通过约定的形式去规避，但是还是需要有更完善的方案去处理

通过实践得出的一些结论：

1. 模块不需要遍历，提供一个遍历函数即可，路由等中间件需要根据原始的依赖关系来进行处理，像国际化这种则不需要依赖关系
2. 中间件做成函数，通过 compose 函数来组合，直接返回 JSX，洋葱模型有点重，暂时不需要这么复杂，入参为 module 和 children，这样一层层包起来即可，严重依赖于顺序
